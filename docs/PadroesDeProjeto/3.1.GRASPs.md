# 3.1. Módulo Padrões de Projeto GRASPs

## Criador
Os padrões de projeto são soluções reutilizáveis para problemas de design comuns em software orientado a objetos (Gamma et al., 1994, p. 15). Eles fornecem um conjunto de diretrizes para a atribuição de responsabilidades a classes e objetos em sistemas orientados a objetos, promovendo a reutilização de código, a coesão alta e o baixo acoplamento. Um dos padrões GRASP mais importantes é o Creator. Este padrão define qual classe deve ser responsável pela criação de instâncias de outras classes. A escolha da classe responsável pela criação é crucial para a organização do sistema e para a manutenção do baixo acoplamento entre as classes. O padrão GRASP Creator sugere que uma classe deve ser responsável pela criação de instâncias de outra classe se uma ou mais das seguintes condições forem verdadeiras:

- **Contém/Composição:** B contém A ou é uma composição de A.
- **Registro:** B registra A.
- **Uso Próximo:** B usa A de maneira muito próxima.
- **Dados de Inicialização:** B tem dados iniciais de A, os quais serão passados para A quando este for criado. B é um “especialista” em relação à criação de A.

### Aplicação no Projeto 
No diagrama fornecido, temos duas classes principais: Catalogo e Jogo. A classe Catalogo contém uma coleção de objetos da classe Jogo e fornece métodos para buscar, filtrar e cadastrar jogos. Já a classe Jogo, por sua vez, representa um jogo individual e contém informações detalhadas como nome, desenvolvedor, editora, plataforma, entre outras.

- **Contém/Composição:** A classe Catalogo contém uma coleção de objetos Jogo. Isso sugere que Catalogo é responsável por gerenciar os objetos Jogo, incluindo sua criação.
- **Registro:** Catalogo registra instâncias de Jogo em sua coleção interna, sendo o ponto central de gerenciamento desses objetos.
- **Uso Próximo:** Catalogo usa objetos Jogo de forma intensiva em seus métodos buscarJogo, filtrarJogos e cadastrarJogo. Como Catalogo precisa criar, armazenar e manipular objetos Jogo frequentemente, faz sentido que ela seja responsável por sua criação.
- **Dados de Inicialização:** Catalogo pode possuir ou ter acesso aos dados necessários para inicializar um objeto Jogo. Por exemplo, ao cadastrar um novo jogo, Catalogo pode coletar todas as informações necessárias e criar a instância do Jogo.

<center><strong>Figura - GRASP Criador</strong></center>

![image](https://github.com/user-attachments/assets/5d60d365-9643-424e-9d5e-603737604a3d)

</center>
<div style="text-align:center;">
Autores: Pedro Henrique, Luciano Ricardo, Luan Melo e Sabrina Caldas
</div>

## Especialista
O padrão de projeto Especialista foca em atribuir as responsabilidades do sistema para as classes mais especializadas dentro de seus contextos. É possível existir classes especializadas na criação de outras classes, no cálculo de valores específicos, no armazenamento de informações e outras possíveis ações realizadas dentro de um sistema. Por se tratar de um padrão amplo é possível de aplicá-lo de diversas formas, porém a principal maneira de enxergar a sua necessidade é quando se entende que uma das responsabilidades do sistema atribuída a uma classe pode ser executada com mais eficiência caso venha a ser construído uma outra própria para essa ação, trazendo diretamente dados e outras informações que facilitam a execução da responsabilidade.

### Aplicação no Projeto
No contexto do projeto, é possível identificar 2 exemplos de aplicações do padrão especialista. O primeiro faz referência a relação entre Biblioteca e Cliente, sendo Biblioteca uma classe especialista no armazenamento dos jogos possuídos pelo cliente. Veja que seria possível atribuir o conjunto de jogos diretamente na classe de Cliente, porém criando a classe especialista se torna possível a listagem de jogos, recursos de filtragem e busca e adições de outras ações, como a opção de favoritar jogos. Caso não existisse a classe especialista de Biblioteca todo escopo da mesma seria implementado em Cliente trazendo informações desnecessárias para os contextos mais frequentes de uso da classe.

A segunda aplicação do padrão especialista é na relação entre Jogo e Avaliação, novamente o escopo da avaliação de um jogo se mostrou grande o suficiente para que a equipe entendesse a necessidade de trazer uma classe especialista para essa responsabilidade.

<center><strong>Figura - GRASP Especialista (Biblioteca)</strong></center>

![image](https://github.com/user-attachments/assets/6d568d4a-5a54-4c5c-b66e-04bf20bb358a)

<center><strong>Figura - GRASP Especialista (Avaliação)</strong></center>

![image](https://github.com/user-attachments/assets/cf6d6812-e9f5-406b-9b75-4abcc2abd4e4)

</center>
<div style="text-align:center;">
Autores: Pedro Henrique, Luciano Ricardo, Luan Melo e Sabrina Caldas
</div>

## Polimorfismo
O GRASP Polimorfismo é um padrão de projeto muito remetente ao conceito de polimorfismo que aprende-se na disciplina de Orientação a Objetos. [1] A sua principal diretriz diz respeito que: A menos que haja um comportamento default na superclasse, declare uma operação polimórfica na superclasse como sendo abstrata. 

Ou seja, utilizamos esse padrão em casos onde há variações de objetos que são semelhantes de alguma forma. Isso implica no uso e criação de classes abstratas ou interfaces, o que já mostra que são os principais tipos de artefatos para serem interpretados como polimorfismo e identificação desse GRASP.

### Aplicação no Projeto
Em nosso projeto de E-Commerce, esse padrão conseguiu ser aplicado na classe responsável por lidar com a forma de pagamento por um jogo que o cliente compra dentro do site. Inicialmente, o nosso [Diagrama de Classes](../Modelagem/2.1.1.UMLEstaticos.md) contou com uma versão onde se encontrava apenas uma classe FormaPagamento, sem que houvesse nenhuma herança ou algo do tipo. 

Com o decorrer do desenvolvimento do diagrama, nossa equipe modificou essa classe para que se tornasse uma classe abstrata a fim de aprimorar o Diagrama de Classes e aplicar as boas práticas do GRASP Polimorfismo em nosso projeto. A partir disso, foi criado uma classe abstrata denominada FormaPagamento na qual as classes Boleto, Pix e Credito herdam dessa como formas especializadas de realizar um tipo de pagamento para a compra de um jogo na plataforma. 

Portanto, pode-se observar a seguir a implementação realizada a nível UML, além de ser possível destacar os principais elementos que tornam a aplicação do GRASP Polimorfismo possível.

<center><strong>Figura X - GRASP Polimorfismo na Classe Abstrata FormaPagamento</strong></center>

<center>

![GRASP Polimorfismo em FormaPagamento](../assets/grasp/polimorfismo.png)

</center>
<div style="text-align:center;">
Autores: Pedro Henrique, Luciano Ricardo, Luan Melo e Sabrina Caldas
</div>

## Histórico de versão

| Data       | Versão | Atividade | Responsável | Revisor |
| ---------- | ------ | --------- | ----------- | ------- |
| 18/07/2024 | 1.0    | Adiciona GRASP Polimorfismo | [Pedro H.](https://github.com/phmelosilva)  | [João S.](https://github.com/JoaoSchmitz) |
| 19/07/2024 | 1.1    | Adiciona GRASP Creator | [Sabrina B.](https://github.com/sabrinaberno) | [Marcus](https://github.com/marcusmartinss)|
| 19/07/2024 | 1.2    | Adiciona GRASP Especialista | [Luan Q.](https://github.com/luanmq) | |

## Referências

    [1] Professora Millene Serrano - Material Complementar (Parte II) - Módulo Padrões de Projeto GRASP(s). Disponível em: <https://aprender3.unb.br/pluginfile.php/2790263/mod_label/intro/Arquitetura%20e%20Desenho%20de%20Software%20-%20Aula%20GRASP_B%20-%20Profa.%20Milene%20-%20Complementar.pdf>. Acesso em: 18 jul. 2024.
    [2] Erich Gamma et al. Design Patterns: Elements of Reusable Object-oriented Software. Addison-Wesley, 1994. Acesso em:19 jul. 2024
